{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../../../opt/homebrew/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"fs\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":[null,"module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// MIT License - Copyright (c) 2020 Stefan Arentz <stefan@devbots.xyz>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\nconst fs = require('fs');\n\nconst core = require('@actions/core');\nconst execa = require('execa');\n\n\nconst parseConfiguration = () => {\n    const configuration = {\n        productPath: core.getInput(\"product-path\", {required: true}),\n        username: core.getInput(\"appstore-connect-username\", {required: true}),\n        teamid: core.getInput(\"appstore-connect-teamid\", {required: true}),\n        password: core.getInput(\"appstore-connect-password\", {required: true}),\n        verbose: core.getInput(\"verbose\") === \"true\",\n    };\n\n    if (!fs.existsSync(configuration.productPath)) {\n        throw Error(`Product path ${configuration.productPath} does not exist.`);\n    }\n\n    return configuration\n};\n\n\nconst archive = async ({productPath}) => {\n    const archivePath = \"/tmp/archive.zip\"; // TODO Temporary file\n\n    const args = [\n        \"-c\",           // Create an archive at the destination path\n        \"-k\",           // Create a PKZip archive\n        \"--keepParent\", // Embed the parent directory name src in dst_archive.\n        productPath,    // Source\n        archivePath,    // Destination\n    ];\n\n    try {\n        await execa(\"ditto\", args);\n    } catch (error) {\n        core.error(error);\n        return null;\n    }\n\n    return archivePath;\n};\n\n\nconst submit = async ({archivePath, username, teamid, password, verbose}) => {\n    //\n    // Run notarytool to notarize this application. This only submits the\n    // application to the queue on Apple's server side. It does not\n    // actually tell us if the notarization was succesdful or not, for\n    // that we need to poll using the request UUID that is returned.\n    //\n\n    const args = [\n        \"notarytool\",\n        \"submit\",\n        \"--wait\",\n        \"--apple-id\", username,\n        \"--team-id\", teamid,\n        \"--password\", password,\n        archivePath\n    ];\n\n    if (verbose === true) {\n        args.push(\"--verbose\");\n    }\n\n    let xcrun = execa(\"xcrun\", args, {reject: false});\n\n    xcrun.stdout.pipe(process.stdout);\n    xcrun.stderr.pipe(process.stderr);\n\n    const {exitCode, stdout, stderr} = await xcrun;\n\n    if (exitCode === undefined) {\n        // TODO Command did not run at all\n        throw Error(\"Unknown failure - notarytool did not run at all?\");\n    }\n\n    if (exitCode !== 0) {\n        const response = JSON.parse(stdout);\n        if (verbose === true) {\n            console.log(\"STDERR\", stderr);\n            console.log(response);\n        }\n\n        for (const productError of response[\"product-errors\"]) {\n            core.error(`${productError.code} - ${productError.message}`);\n        }\n        return false;\n    }\n\n    return true;\n};\n\nconst main = async () => {\n    try {\n        const configuration = parseConfiguration();\n\n        const archivePath = await core.group('Archiving Application', async () => {\n            const archivePath = await archive(configuration)\n            if (archivePath !== null) {\n                core.info(`Created application archive at ${archivePath}`);\n            }\n            return archivePath;\n        });\n\n        if (archivePath == null) {\n            core.setFailed(\"Notarization failed\");\n            return;\n        }\n\n        const success = await core.group('Waiting for Notarization Status', async () => {\n            return await submit({archivePath: archivePath, ...configuration})\n        });\n\n        if (success == false) {\n            core.setFailed(\"Notarization failed\");\n            return;\n        }\n\n        core.setOutput('product-path', configuration.productPath);\n    } catch (error) {\n        core.setFailed(`Notarization failed with an unexpected error: ${error.message}`);\n    }\n};\n\n\nmain();\n"],"names":[],"sourceRoot":""}